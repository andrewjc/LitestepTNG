LiteStep Theme Engine V2
========================

1. Purpose and Goals
--------------------
- Provide a modern, component-centric theme definition model that is simple to read and author yet powerful enough for complex shell layouts.
- Keep the surface area deliberately small: a handful of core structural primitives, declarative layout and data binding, optional behaviors, and a separate styling dialect.
- Represent themes as hierarchical graphs of nodes that map directly onto existing LiteStep modules; no module must change to participate.
- Maintain first-class support for legacy `step.rc`/`theme.rc` bang syntax so mixed deployments are fully supported.

2. File Layout and Loading Order
--------------------------------
- `theme.lsx` (structure): Declares the component tree. Curly braces describe nodes, arrays express ordered child collections, objects describe parameter maps.
- `*.lsxstyle` (style): Declares visual properties, declaratively applied to nodes identified by id, component type, class, or pseudo-selector. Multiple style files can be imported.
- Optional supporting files: `constants.lsx` for shared literal values, `*.lsxinc` fragments for reusable subtrees, and existing `.rc` files.
- Load order inside the theme engine:
  1. Parse `step.rc` as usual to initialize LiteStep, load modules, and define bangs/variables.
  2. When the V2 engine is enabled, resolve `theme.lsx` (or file referenced by `LSThemeV2File` env var). Apply `#include` directives to inline other `.lsx` or `.lsxinc` sources.
  3. Resolve styling imports declared with `#include=*.lsxstyle`. Each style file is parsed after the structural tree to ensure selector validation against known ids/classes occurs.
  4. Build the node graph, then bind it to already-loaded modules and apply computed styles. Existing RC commands that are not mirrored in the markup continue to execute.

3. Runtime Architecture Overview
---------------------------------
- **ThemeEngineV2**: Orchestrates loading, parsing, validation, binding, layout, and hydration. Exposes a control surface via new bangs (`!ReloadThemeV2`, `!InspectThemeV2`).
- **SourceManager**: Resolves `#include` and environment substitution. Tracks file origins for diagnostics and hot reload.
- **Lexer**: Tokenizes `.lsx` and `.lsxstyle` files. Supports comments (`//` single line, `/* */` block), string literals with escapes, numbers (integer, float, percentages), identifiers, function calls, and structural punctuation.
- **Parser**: Transforms tokens into AST nodes:
  * Structural grammar yields `ComponentNode`, `ObjectLiteral`, `ArrayLiteral`, and `Expression` nodes.
  * Style grammar yields `SelectorRule`, `Declaration`, and `StyleExpression` nodes.
- **AST Validator**: Performs static checks (duplicate ids, unknown properties, invalid layout hints, unresolved constants).
- **NodeGraphBuilder**: Creates an in-memory component graph (DAG) with parent/child edges, references to module bindings, and resolved property bags.
- **ModuleRegistry**: Discovers all LiteStep modules present in memory (via existing LSAPI enumeration) and holds metadata describing accepted bangs, variables, and configuration keys. For modules without metadata manifests, introspection uses existing `.rc` alias declarations to infer property names.
- **PropertyAdapter**: Translates node attributes into the key/value instructions each module expects. Outputs sequences of legacy `*ModuleName` lines or direct LSAPI configuration calls so legacy binaries receive unchanged input.
- **LayoutEngine**: Performs constraint resolution for supported layout strategies (`stack`, `grid`, `overlay`, etc.) and emits geometry for modules that render visual elements.
- **StyleEngine**: Resolves selector matches, cascades declarations, evaluates style expressions, and feeds the resulting visual tokens to modules that support styling, or stores them as overlay metadata used by wrapper components.
- **BindingRuntime**: Bridges between graph nodes and module instances. Responsible for instantiation (if necessary), property diffing during hot reload, and dispatching runtime events back into the graph (e.g., button clicks, task updates).

4. Structural Markup Syntax
----------------------------
- Source begins with optional directive lines prefixed by `#`, e.g., `#lstheme`, `#include=path`, `#pragma setting=value`.
- Components are declared with `#ComponentName { ... }`. ComponentName is case-insensitive and maps to a module or abstract primitive registered with the engine.
- Inside a component block, declare attributes as `identifier = value`. Supported literal value forms:
  * Strings enclosed by double quotes with `\` escapes.
  * Numbers: `42`, `3.14`, `90%`, `12px`, `2em`. Units are normalized by the layout engine.
  * Booleans: `true`, `false`.
  * Identifiers: `auto`, `fill`, `horizontal` (resolve through enums, constants, or module adapters).
  * Object literals: `{ key1=value1, key2=value2 }` (commas optional while whitespace separates pairs).
  * Array literals: `[ item1, item2, ... ]`. Trailing commas allowed.
  * References: `@id` refers to another node by `id`/`name`. `&var` references an environment variable.
- Comments: `//` until end-of-line; `/* ... */` allowed anywhere whitespace allowed.
- Snippets can be imported inline with `#include-subtree "path.lsxinc"` to reduce duplication.
- Implied root: the outermost `{ ... }` literal defines the contents of the virtual root. Multiple siblings are allowed; they attach to a synthetic `Root` component that handles global layout/hit testing.
- Example mapping from legacy RC:
  * Legacy: `*nTaskbar TaskbarMain`. V2: `#Taskbar { name = "TaskbarMain" }`.
  * Legacy: `TaskbarMainFontSize 12`. V2 property on same node: `FontSize = 12`.

5. Style Syntax (`.lsxstyle`)
-----------------------------
- General shape:
  ```
  selector[, selector]* {
     property = value
     property = function(arg).chain()
  }
  ```
- Selectors support:
  * `all` (universal)
  * `#id` (by node `name` attribute, case-insensitive)
  * `.class` (by `class` attribute; multiple classes space-separated)
  * `[component=Taskbar]` or `[module=nTask]`
  * Pseudo-selectors: `:hover`, `:active`, `:disabled`, `:focus`, `:first-child`, `:last-child`
- Values mirror structural literals plus chained style functions: `alpha(90)`, `blur(30)`, `tint(color, percent)`, `gradient(type, stop...)`. Chains apply left-to-right: `alpha(90).blur(30)`.
- Declarations cascade using CSS-like specificity: id > class/module > component > universal > inherited.
- Variables: `@Identifier` inside style values resolves to constants exported from `.lsx` files or environment variables defined in `step.rc`.
- Style names applied from structure: `style = "searchbox"` attaches a virtual class `.style-searchbox` to the node before style resolution.

6. Component Catalog (Initial Set)
----------------------------------
- Structural primitives:
  * `Root` (implicit): Coordinates layout across monitors and surfaces.
  * `Panel`: Container mapping to `Panels.dll` or other host modules, offering `layout`, `layoutParams`, `background`, `border`, `shadow`, `children`.
  * `Spacer`: Zero-footprint spacing element. When mapped to legacy modules, translates to `width`/`height` directives only.
  * `Stack`, `Grid`: Convenience aliases for `Panel` with preconfigured layout.
- Interactive elements:
  * `Button`: Binds to whichever module exposes button semantics (e.g., `nPopup`, `nTray`, custom). Properties: `icon`, `text`, `tooltip`, `onClick` (maps to bang string), `style`.
  * `Launcher`: Wraps LS `Shortcut`/`!Execute` semantics. Properties: `path`, `arguments`, `icon`, `tooltip`.
  * `TaskItem`: Bridges to `nTask` entries. Accepts `title`, `icon`, `windowId`, `active`.
- Informational:
  * `TextLabel` (`nLabel`), `Icon` (`nTray`/`Panels.dll`), `Clock` (`nClock`), `Tray` (`nTray`).
- Utility nodes:
  * `DataSource`: Binds to LS variables or plugin data for injection into child expressions.
  * `Behavior`: Attaches event listeners or state machines without visual output.
- Extensibility:
  * `#module("SomeModule.dll") { ... }` registers an ad-hoc node that proxies all attributes directly to the named module using the adapter.

7. Property Binding and Adapter Strategy
----------------------------------------
- Each component type has an associated `ComponentDescriptor` describing:
  * Canonical module name(s).
  * Accepted property names (friendly) and their legacy equivalents (bang, rc key, LSAPI call).
  * Value converters (string -> LS variant) and default values.
  * Lifecycle hooks (before instantiate, after apply, before release).
- Property resolution order: node attributes override defaults; style declarations may update visual properties, but never structural invariants such as `name` or `module`.
- When a node is instantiated, `PropertyAdapter` emits one of:
  * `*ModuleAlias <Name>` directive (if the target module expects RC style instantiation).
  * `!bang arguments` command (for dynamic updates).
  * Direct call to LSAPI property setter when available.
- All property changes are diffed to avoid redundant operations, ensuring modules not designed for repeated initialization continue to behave.
- Legacy `.rc` fragments may still add commands for advanced behaviors; in V2 markup they can be invoked via `onInit = "!Bang"`, `onClick`, etc.

8. Lexer and Parser Details
---------------------------
- Lexer tokens: `Identifier`, `HashIdentifier`, `Number`, `String`, `Boolean`, `LBrace`, `RBrace`, `LBracket`, `RBracket`, `Equals`, `Comma`, `Colon`, `Dot`, `ParenOpen/Close`, `Reference`, `AtReference`, `Operator` (for style chaining), `Directive`, `Newline`.
- Structural grammar sketch (EBNF):
  ```
  theme      := directive* block
  directive  := '#' identifier (('=' value) | value)? newline
  block      := '{' (statement (','? statement)*)? '}'
  statement  := component | assignment
  component  := '#' identifier object
  assignment := identifier '=' value
  object     := '{' (assignment (',' assignment)*)? (','? children)? '}'
  children   := 'children' '=' array
  array      := '[' (value (',' value)*)? ']'
  value      := literal | object | array | reference | expression
  ```
- Style grammar sketch:
  ```
  stylesheet := rule*
  rule       := selectorList '{' declaration* '}'
  selectorList := selector (',' selector)*
  selector   := simpleSelector (pseudoSelector)*
  simpleSelector := 'all' | '#' identifier | '.' identifier | '[' identifier '=' identifier ']'
  declaration:= identifier '=' styleValue
  styleValue := literal ('.' identifier '(' argumentList? ')')*
  ```
- Expression support kept intentionally narrow: arithmetic limited to `+ - * /` on numeric literals and constants; no general scripting.
- Error handling: Lexer emits structured diagnostics (file, line, column, snippet suggestion). Parser uses panic-mode recovery at statement boundaries to keep reporting multiple issues in one pass.

9. Node Graph and Layout Model
------------------------------
- Every node stores: `id/name`, `component`, `module`, `properties`, `children`, `bindings`, `computedLayout`, `computedStyle`, `dataContext`.
- Layout engine supports three built-ins:
  * `stack`: one-dimensional flex layout. Supports `direction`, `align`, `spacing`, `wrap`, `gap`.
  * `grid`: two-dimensional grid with row/column definitions, `gutters`, `areas`, `justify`.
  * `overlay`: absolute positioning relative to parent bounds. `x`, `y`, `width`, `height`, `anchor`.
- Layout metadata is translated to the actual module configuration: e.g., `layoutParams.align="right"` on `#Panel` maps to `Panels.dll` alignment flags.
- Geometry updates propagate to modules via `!Set*` bangs or direct LSAPI calls. Modules lacking runtime geometry APIs fallback to static configuration and require theme reload to change geometry; this is documented per component.

10. Legacy Compatibility Strategy
---------------------------------
- Legacy `step.rc` is parsed first; any modules instantiated there remain active. The V2 engine reads the resulting environment (aliases, bangs, module handles) to ensure V2 nodes can attach to them.
- When both systems reference the same module instance, the engine detects the `name`/`id` collision and adopts the existing instance instead of creating a duplicate.
- Properties defined in `.rc` continue to apply; V2 assignments layer on top using the existing module API without fighting the original settings. Conflicts are resolved by precedence rules configurable per module (default: V2 overrides when explicitly set).
- Theme authors can mix syntaxes: e.g., keep complex `nPopup` menus in `.rc` while migrating visual layout to `.lsx`.
- `theme.rc` remains optional. If present, it executes after `step.rc` but before V2 hydration, allowing it to define helper bangs used in markup.
- Hot reload: `!Reload` still reloads `.rc` files; `!ReloadThemeV2` re-parses `.lsx` files and reapplies diffed changes without disturbing untouched legacy modules.

11. Implementation Notes
------------------------
- Lexer/Parser should be implemented in C++ (matching existing LiteStep core) with reentrant design to allow background parsing for live preview.
- AST nodes stored in arena allocator for performance; expose immutable views to runtime components.
- Style engine uses a lightweight cascade cache keyed by `(selector hash, node id)` to accelerate reflows.
- Provide diagnostic commands (`!ThemeV2DumpAST`, `!ThemeV2DumpGraph`) writing JSON snapshots to `%LiteStepDir%\dumps` to aid debugging and third-party tool integration.
- Export a scripting bridge (Lua/.NET) via existing LS API hooks so advanced users can inspect or mutate the node graph programmatically.

12. Authoring Workflow and Migration
------------------------------------
- Create or update `step.rc` to load `LiteStepVersion 0.25+` and enable V2: `SetEnv LSTHEME_V2_ENABLED true`.
- Author structure in `theme.lsx`. Use `#include=constants.lsx` to reuse shared sizing tokens (e.g., `PADDING_SMALL`).
- Author visual tweaks in `theme.lsxstyle`; reuse selectors across multiple nodes via `class = "primary"`.
- Keep existing `.rc` fragments for behaviors not yet expressed in V2; gradually migrate by replacing `*ModuleAlias` blocks with component nodes.
- Validate with `!ThemeV2Validate` to see parser or binding warnings in the LiteStep log.
- Ship both `theme.lsx` and fallback `.rc` files so older LiteStep builds still load.

Appendix A: Sample Legacy Mapping
---------------------------------
Legacy snippet:
```
*nTaskbar TaskbarMain
TaskbarMainFontSize 12
TaskbarMainPlacement top right
```
V2 equivalent:
```
#Taskbar {
   name = "TaskbarMain"
   FontSize = 12
   Placement = "top-right"
}
```
The adapter emits the same `*nTaskbar` line and `TaskbarMainFontSize 12` to the module during hydration, preserving behavior.

Appendix B: Reserved Keywords
-----------------------------
- Structural: `children`, `layout`, `layoutParams`, `style`, `class`, `id`, `name`, `module`, `onInit`, `onClick`, `data`, `bind`.
- Style: `all`, `inherit`, `initial`, `alpha`, `blur`, `tint`, `dropShadow`, `gradient`, `radius`, `padding`, `margin`.
